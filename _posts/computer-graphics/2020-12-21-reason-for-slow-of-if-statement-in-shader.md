---
layout: post
title:  "쉐이더에서 IF 문이 느린 이유"
date:   2020-12-21 18:00:00 +0900
categories: computer-grahics
tags: [shader, optimization]
difficulty: middle
---
## 개요
쉐이더에서 IF 문이 성능에 좋지 않다는 것은 프로그래머가 아니더라도 많이들 알고 있는 사실이다.

중요한 것은 단순히 IF 문이 느리다는 것이 아니다, IF 문이 필요해서 IF 문을 쓰는 것인데 느리다는 사실을 아는 것만으로는 별로 도움이 되지 않는다.
왜 IF 문이 느린 것인지를 아는 것이 중요하고, 그것을 제대로 알아야 IF 문을 우회하는데 도움이 될 수 있다[^1].

최적화 이슈에서 이유를 잘못 알고 어떤 결과만 아는 것은 독이 될 수도 있다. 잘못된 결론을 내버리면 잘못된 최적화로 최적화가 안되기는 커녕 더 느려질 수도 있다.
따라서 왜 느린지를 제대로 아는 것은 특히 프로그래머라면 매우 중요하다.

## GPU의 동작 방식
CPU의 코어는 개별적으로 도는데에 비해 GPU의 코어는 묶음으로 돈다. SIMT(Single Instruction, Multiple Threads)라는 용어가 그 특성을 잘 설명한다. GPU에서는 여러 쓰레드(코어)가 동시에 하나의 명령어를 수행한다. 일반적으로 이 묶음은 32개 혹은 64개다[^2]. 동시에 32개를 계산하니 빠름과 동시에 여러 단점도 존재한다. 대표적인 예가 IF/ELSE 문에 의한 **다이나믹 브랜칭(dynamic branch 혹은 brance divergence)**이다.

```cpp
if (cond) // line 1.
{
    finalColor = hairShading(); // line 3. 머리카락 쉐이딩 계산 (무거움)
}
else
{
    finalColor = clothShading(); // line 7. 옷 쉐이딩 계산 (무거움)
}
```

위의 극단적인 코드를 보자. 32개(64개도 있지만 여기서는 32개로 고정하겠다) 쓰레드가 동시에 같은 명령어를 처리해야하니 여기서 GPU는 hairShading과 clothShading을 모두 호출하게 된다.
더 정확하게 말하면 다음과 같은 순서로 수행 된다.

1. cond 에 해당하는 플래그를 각 쓰레드의 레지스터에 넣는다. (line 1)
2. hairShading 을 수행한다. 이때 위에서 저장한 cond 플래그가 **true** 인 경우만 finalColor 변수에 결과를 넣는다. (line 3)
3. clothShading 을 수행한다. 이때 위에서 저장한 cond 플래그가 **false** 인 경우만 finalColor 변수에 결과를 넣는다. (line 7)

2번과 3번에서 플래그가 맞지 않은 계산은 그냥 버린다. GPU는 동시에 계산을 해야하기 때문에 일단 계산은 하고 조건에 맞는 결과만 저장한다. 즉, 다이나믹 브랜칭에서는 **모든 분기를 불필요하게 다 계산한다**.
물론 CPU에서는 이럴 필요가 없다. IF 문 조건에 맞아 수행을 하면 GOTO 문으로 분기를 빠져나간다. 모든 분기를 다 수행하는 것이 다이나믹 브랜칭이다.

여기서 오해를 할 수도 있으므로 다른 코드를 보자[^3].

```cpp
float4 hairShadingResult = hairShading();
float4 clothShadingResult = clothShading();

if (cond)
{
    finalColor = hairShadingResult;
}
else
{
    finalColor = clothShadingResult;
}
```

이런 경우 브랜칭이 별거 아닌 것처럼 오해하기 쉽다. 이렇게 보면 대입 두번 정도 하는 것이 별거 아닌 것처럼 보이지만, 모든 분기를 다 계산한다는 것은 근본적으로는 전혀 달라지지 않는다.
어셈블리 수준에서 IF / GOTO 명령어 자체가 느린 것은 아니기 때문에 그런 명령어 한둘이 사라졌다고 브랜칭 문제가 사라지는 것은 아니다.
이렇게 하는 것은 성능상 아무런 이점이 없는데다 심지어 컴파일러의 최적화를 방해할 수도 있다(아래 섹션 '생각보다는 똑똑한 GPU' 참고).

즉, 이 코드의 문제는 hairShadingResult와 clothShadingResult의 계산 자체가 느린 것이 문제고 그것을 불필요하게 두번 하는 것이 문제다. IF 문 때문에 대입을 두번한다고 느려지진 않는다.
위 코드에서 (cond 플래그가 섞여 있을 때) hairShading() 과 clothShading() 두 함수는 둘다 호출 된다.
머리카락이면서 옷인 재질이라서 위 함수를 모두 수행해야한다면 어쩔 수 없지만 둘 중 하나만 처리해도 되는 상황에서 둘다 처리하는 것이 다이나믹 브랜칭이 문제점이다.
이는 실제로 성능에 굉장히 큰 영향을 준다(두 종류가 아니라 더 여러 종류라면 상황은 더 심각하다).

### 생각보다는 똑똑한 GPU
이런 상황에서 희망은 있다. 만약 32개의 쓰레드의 **cond 값이 모두 true 이거나 false 이면** 걱정할 필요가 없다.

```cpp
if (cond) // cond 는 모두 ture 이거나 false
{
    finalColor = hairShading();
}
else
{
    finalColor = clothShading();
}
```

이 경우는 브랜칭 문제가 생기지 않느다. 가령 32개의 쓰레드의 cond 가 모두 true 이면 hairShading 만 처리하고 굳이 clothShading 은 처리 할 필요가 없다는 것을 GPU가 알 수 있기 때문에 else 부분은 수행하지 않고 넘어간다. 물론 이런 최적화는 처음부터 되었던건 아니다. 옛날 GPU는 cond 의 상태와 무관하게 둘다 동작했지만 지금은 똑똑하게 처리해준다.

### 문제의 상황
진짜 문제가 되는 상황은 32개의 쓰레드 내에서 머리카락이거나 옷이 섞여 있을 경우다. 일반적으로 옷과 머리카락은 처리가 매우 무겁다. 
머리카락과 옷이 떨어져 있어서 섞여 있지 않다면 대체적으로 문제가 없겠지만 섞여 있는 부분이 화면에 많으면 많을 수록 심각하게 느려지는 요인이 된다. 실제로 프로파일링을 해보면 경계 부분에 성능을 많이 잡아 먹는 것을 시각적으로도 쉽게 확인할 수 있다.

## 해결 방법
해결 방법은 말처럼 항상 간단한 것은 아니다. 재차 언급하자면 IF 문은 필요에 의해 쓰는 것이기 때문에 쉽게 없앨 수 있는 것은 아니다.

크게 두가지 방식이 있다.
#### 1. 가능한 공용 코드는 한번만 계산한다.

가령 머리카락과 옷의 라이팅 계산 중 디퓨즈 계산의 경우 (처리가 동일하다면) 각 함수 안에서 하는 것 보다 밖으로 빼는게 낫다. 디퓨즈 계산 자체야 별거 안되지만 레지스터 사용량 등을 생각했을 때 굳이 안에서 할 이유는 없어보인다(물론 상황마다 다르다).
가급적 공통적인 계산은 브랜치와 무관하게 공통으로 계산하는 것이 첫번째 방법이다.

#### 2. 쉐이더 분리 (쉐이더 퍼뮤테이션)

언리얼 엔진에서는 쉐이더 퍼뮤테이션(shader permutation)이라는 용어를 사용하는데 유니티에서는 쉐이더 베리언트(shader variants)라는 용어를 사용한다. 근본적으로는 같다. 쉐이더 코드 안에서 #define 으로 하나의 코드를 여러 코드로 분리하는 것이다.

쉐이더를 분리한다고 간단히 해결 되는 것은 아니다. hairShading / clothShading 각각을 분리한 후 공용으로 처리하는 쉐이더를 또 따로 방법도 있고(이 경우 일반적으로 성능 향상에 직접적으로 크게 도움이 되진 않는다),
hairShading 과 clothShading 만 분리해서 겹치는 지역에는 각각 한번씩 돌리는 방법이 있다. 이 경우 스텐실 등을 이용해서 불필요한 경우 관련된 처리가 아예 돌아가지 않도록 보장 해야한다.
쉐이더가 두번 도는 오버헤드가 존재하지만, 머리카락과 옷의 처리가 매우 무겁다면 이 오버헤드를 감안하고 성능향상이 있을 수 있다.

## 마무리
IF 문에 의한 다이나믹 브랜칭은 비싸다. 하지만 중요한 것은 **IF 문이 비싸다**는 단순한 결론 보다는 왜 비싼지를 아는 것이다. 실제로는 IF 문이 비싼 것이 아니다.
이런 과정을 더 깊게 안다면 우리는 GPU를 더 깊게 이해할 수 있다.

결론적으로 GPU는 IF 문으로 인해서 IF/ELSE 코드를 둘다 수행하게 될 수 있고 이 내부의 처리(더 나아가 이 내부와 연관된 처리)가 비싸다면 엄청 비쌀 수 있다.
따라서 단순히 IF 문이 여러 비싼 처리를 분기적으로 처리할 때는 매우 조심해야한다. 이에 대한 해결 방법은 여러가지가 있지만 항상 그렇게 단순한 것은 아니기 때문에 위험성을 항상 염두하는 것이 중요하다.

[^1]: IF 문은 필요에 의해서 쓰는 것이기 때문에 IF 자체를 줄일 수 있는 방법은 많지 않다.
[^2]: 이 묶음은 NVIDIA에서는 warp 라는 단어를 사용하며 32개의 쓰레드로 구성 되어 있다. 반면 AMD는 wavefront 라는 단어를 사용하며 64개의 쓰레드다.
[^3]: 이 오해의 예시는 다른 블로그에서 봤다. 여기서는 이 블로그를 비난하는 목적이 아니기 때문에 이 예시의 출처는 적지 않겠다.